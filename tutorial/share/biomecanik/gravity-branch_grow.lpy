from math import sqrt, pi, degrees
from openalea.plantgl.math import *
from copy import deepcopy

# Paramaters
# ##########

# Branches attributes
# ===================

N = 10         # initial number of segments in the stem
S_LEN   = 0.1        # in m
S_TRUNC = 1.2        # in m
S_DIAM  = 0.01       # in m
WoodDensity = 1000   # volumic mass of wood = 0.8 kg/L
YoungModElasticity = 5*10.**8   # Ex: Mapple = 10000 MPa; Oak = 11000 MPa; Pine =  9000 MPa

# Gravity model parameters
# ========================

Gravity = Vector3(0,0,-10.0)  # in N/Kg

# Simulation parameters
# =====================

RELAX = 0.8     # relax factor for convergence (<0.9)
eps = 0.1           # epsilon (error)
derivationstep = 0
derivlen = 50

# Spread parameter
# ================

Forward,Backward,Growth=range(3)
mode = Forward   # can be one of FORWARD, BACKWARD

# Branch segments method
# ######################

class SegmentData:
  "data associated with a segment"

  def __init__(self):
    self.len = S_LEN
    self.diam = S_DIAM
    self.H = Vector3(0,1,0) 
    self.cummass = 0 
    self.cumtorque=Vector3() 

  def getMass(self):
    return self.len*pi*(self.diam**2)/4*WoodDensity
  mass = property(getMass)

  def getMomentOfInertia(self):
    return pi * self.diam**4 / 64 # for a disc  
  momentOfInertia = property(getMomentOfInertia)

  def getRigidity(self):
    return YoungModElasticity * self.momentOfInertia
  rigidity = property(getRigidity)

  def __repr__(self):
    return ''

# Simulation
# ##########
    
# Simultation mode 
# ================

def setMode(m):
  global mode
  mode = m
  # print "mode = ", mode
  if m == Forward : forward()
  elif m == Backward: backward()
  elif m == Growth : forward()
  else: print "UNKNOWN MODE !!! "

def isFORWARD(): 
  global mode
  return mode == Forward
  
def isBACKWARD(): 
  global mode
  return mode == Backward
  
def isGROWTH(): 
  global mode
  return mode == Growth

def Start():
  setMode(Growth)
  global derivationstep
  derivationstep = 0

def StartEach ():
  global error 
  global derivationstep
  derivationstep += 1
  error = 0

def EndEach ():
  global error, mode, eps
  if mode == Growth:
    setMode(Backward)
  elif mode == Backward : 
    setMode(Forward)
  elif mode == Forward and error >= eps : 
    print ">>> mean error = ", error
    setMode(Backward)
  elif mode == Forward: 
    print "EQUILIBRIUM REACHED: mean error = ", error, " < ", eps
    setMode(Growth)
     
# Simulation: Physics
# ===================

def update_physic(segment, segment_next): #S(a) >> S(b)
  segment.cummass = segment.mass + segment_next.cummass # cummass update (case segment mass growing)
  segvec =  segment_next.H * segment_next.len
  weightvec =  Gravity * segment_next.cummass
  segment.cumtorque = segment_next.cumtorque + (segvec ^ weightvec)

def apply_torque(segment, segment_previous):#S(c) << S(a)
  global error
  curvature = segment_previous.cumtorque * (1/segment.rigidity) * segment.len
  rot = Matrix3.axisRotation((1,0,0),curvature[0]) #in the plane
  newH = rot * segment_previous.H
  diff = newH - segment.H
  error += norm(diff)
  #print(error)
  v = segment.H + diff * RELAX
  segment.H = v / norm(v)

# L-py generation
# ###############

# Axioms
# ======

Axiom: T(SegmentData())B(N)

# Rapid Information Transfert: Backward and forward computation for flexion
# =========================================================================

derivation length: derivlen

production:

S(a) >> S(b):
  if isBACKWARD():
    update_physic(a,b)
    produce S(a)

T(a) >> S(b):
  if isBACKWARD():
    update_physic(a,b)
    produce T(a)

S(a) >> A:
  if isBACKWARD():
    a.cummass = a.mass 
    a.cumtorque = Vector3(0,0,0)#re-initiate cumtorque
    produce S(a)

S(c) << S(a):
  if isFORWARD():
    global error 
    apply_torque(a, c)
    produce S(a)

T(c) << S(a):
  if isFORWARD():
    global error 
    apply_torque(a, c)
    produce S(a)
    
# L-system: growing
# =================

S(a) < A:
  if isGROWTH():
    print "GROWTH ------------------ GROWTH"
    produce S(deepcopy(a)) A

# L-system: production
# ====================

decomposition:
maximum depth: 100

B(n) :
  if n>0:
    produce S(SegmentData())B(n-1)
  else: produce A

# display
# #######

homomorphism:


T(c):
  produce _(S_DIAM*1.4)F(S_TRUNC)

T(c)<S(a):
  alpha = degrees(angle(Vector3(0,1,0),a.H,(1,0,0)))
  produce -(90)+(alpha)f(0.1*a.len)_(a.diam)F(0.9*a.len)

S(c)<S(a) :
  alpha = degrees(angle(c.H,a.H,(1,0,0)))
  produce +(alpha)f(0.1*a.len)_(a.diam)F(0.9*a.len)

###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_4 = pgl.Material("Color_4" , ambient = (0,0,50) , diffuse = 3.6 , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
__copyright__ = 'open-source GPL'
__references__ = '1. Jirasek, C., Prusinkiewicz, P., Moulia, B. Integrating biomechanics into developmental plant models expressed using L-systems. Proc. 3rd Biomechanics conf. Plant biomechanics 2000. P615-624.\n2. Prusinkiewicz, P., Karwowski, R, Lane, B. The L+C modelling language.J. Vos et al. Eds, Springer, p27-42, 2007\n3. Costes et al. MappleT: Simulation of apple tree development using mixed statistical and biomechanical model. FSPM07.'
__description__ = '- Decrease the Young modulus\n\n- test different values of the relax papameter (including values closed to 1)\n\n- Grow the diameter of the internodes with time'
__institutes__ = 'INRIA - CIRAD Virtual Plants'
__authors__ = 'C. Godin, F. Boudon'
