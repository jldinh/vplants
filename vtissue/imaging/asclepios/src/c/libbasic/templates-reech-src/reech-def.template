/* CAUTION
   DO NOT EDIT THIS FILE,
   UNLESS YOU HAVE A VERY GOOD REASON 
 */

#include <libbasic/reech/reech-defTYPE.h>

/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (flottante) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice
   - le numero de la coupe

   Je prefere faire comme ca pour pouvoir facilement gerer 
   une lecture plan par plan du champ de deformation si necessaire.

   Pas de conversion faite a cause de l'eventualite d'un biais et 
   d'un gain.
*/

void ReechTriLinDefBack_TYPE ( void *theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of buffers */
			       r32* resBuf,  /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       r32** theDef, /* deformations */
			       double* mat,  /* transformation matrix */
			       int slice     /* slice index */
			       )
{
  register int i, j, k=slice, ix, iy, iz;
  register double xd, yd, zd, x, y, z;
  register double dx, dy, dz, dxdy,dxdz,dydz,dxdydz;
  register double res;
  double v6, v5, v4;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  int toffset1=tdimxy+tdimx+1, toffset2=tdimxy-tdimx-1;
  register int t1dimx=tdimx-1, t1dimy=tdimy-1, t1dimz=tdimz-1;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register TYPE *tbuf = (TYPE*)theBuf;
  register TYPE *tpt;
  register r32* rbuf = resBuf;
  register r32* defx = theDef[0];
  register r32* defy = theDef[1];
  register r32* defz = theDef[2];

  for ( j = 0; j < rdimy; j ++ )
  for ( i = 0; i < rdimx; i ++, rbuf ++, defx ++, defy ++, defz ++ ) {
    /* computation of the corresponding point after deformation */
    xd = (float)i + *defx;
    yd = (float)j + *defy;
    zd = (float)k + *defz;
    /* computation of the corresponding point after matrix application */
    x = mat[0] * xd +  mat[1] * yd + mat[2] * zd + mat[3];
    if (( x < -0.5 ) || ( x > ddimx)) { *rbuf = 0; continue; }
    y = mat[4] * xd +  mat[5] * yd + mat[6] * zd + mat[7];
    if (( y < -0.5 ) || ( y > ddimy)) { *rbuf = 0; continue; }
    z = mat[8] * xd +  mat[9] * yd + mat[10] * zd + mat[11];
    if (( z < -0.5 ) || ( z > ddimz)) { *rbuf = 0; continue; }

    /* here, the point lies on the borders or completely inside
       the image */
    ix = (int)x;
    iy = (int)y;
    iz = (int)z;
    tpt = (TYPE *)tbuf;

    /* are we on the border or not ? */
    if ( (x > 0.0) && (ix < t1dimx) &&
	 (y > 0.0) && (iy < t1dimy) &&
	 (z > 0.0) && (iz < t1dimz) ) {
      /* the corresponding point is in the box defined 
	 by (ix[+1],iy[+1],iz[+1]) */
      dx = x - ix;
      dy = y - iy;
      dz = z - iz;
      dxdy = dx*dy;
      dxdz = dx*dz;
      dydz = dy*dz;
      dxdydz = dxdy*dz;
      
      /* we have
	 v[7]=dxdydz;            coefficient of tbuf(ix+1,iy+1,iz+1)
	 v[6]=dxdz-dxdydz;       coefficient of tbuf(ix+1,iy,  iz+1)
	 v[5]=dxdy-dxdydz;       coefficient of tbuf(ix+1,iy+1,iz  )
	 v[4]=dx-dxdy-v[6];      coefficient of tbuf(ix+1,iy  ,iz  )
	 v[3]=dydz-dxdydz;       coefficient of tbuf(ix  ,iy+1,iz+1)
	 v[2]=dz-dydz-v[6];      coefficient of tbuf(ix  ,iy  ,iz+1)
	 v[1]=dy-dydz-v[5];      coefficient of tbuf(ix  ,iy+1,iz  )
	 v[0]=1-dy-dz+dydz-v[4]; coefficient of tbuf(ix  ,iy  ,iz  )
      */
      tpt += ix + iy * tdimx + iz * tdimxy + toffset1;
      v6 = dxdz-dxdydz;
      v5 = dxdy-dxdydz;
      v4 = dx-dxdy-v6;
      
      res = 0;
      res += dxdydz * (*tpt);            /* tbuf(ix+1,iy+1,iz+1) */
      tpt --;
      res += (dydz-dxdydz) * (*tpt);     /* tbuf(ix  ,iy+1,iz+1) */
      tpt -= t1dimx;
      res += v6 * (*tpt);                /* tbuf(ix+1  ,iy,  iz+1) */
      tpt --;
      res += (dz-dydz-v6) * (*tpt);      /* tbuf(ix  ,iy  ,iz+1) */
      tpt -= toffset2;
      res += v5 * (*tpt);                /* tbuf(ix+1,iy+1,iz  ) */
      tpt --;
      res += (dy-dydz-v5) * (*tpt);      /* tbuf(ix  ,iy+1,iz  ) */
      tpt -= t1dimx;
      res += v4 * (*tpt);                /* tbuf(ix+1,iy  ,iz  ) */
      tpt --;
      res += (1-dy-dz+dydz-v4) * (*tpt); /* tbuf(ix  ,iy  ,iz  ) */
      *rbuf = res;
      continue;
    }
    /* here, we are sure we are on some border */
    tpt += ix + iy * tdimx + iz * tdimxy;
    if ( (x < 0.0) || (ix == t1dimx) ) {
      if ( (y < 0.0) || (iy == t1dimy) ) {
	if ( (z < 0.0) || (iz == t1dimz) ) {
	  *rbuf = *tpt;
	  continue;
	}
	dz = z - iz;
	res  = (1-dz) * (*tpt); /* (1-dz)* tbuf(ix,iy,iz) */
	tpt += tdimxy;
	res += dz * (*tpt);     /* dz * tbuf(ix,iy,iz+1) */
	*rbuf = res;
	continue;
      }
      dy = y - iy;
      if ( (z < 0.0) || (iz == t1dimz) ) {
	res  = (1-dy) * (*tpt); /* (1-dy)* tbuf(ix,iy,iz) */
	tpt += tdimx;
	res += dy * (*tpt);     /* dy * tbuf(ix,iy+1,iz) */
	*rbuf = res;
	continue;
      }
      dz = z - iz;
      res = (1-dy)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt += tdimx;
      res += dy*(1-dz) * (*tpt);    /* tbuf(ix,iy+1,iz) */
      tpt += toffset2+1;
      res += (1-dy)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
      tpt += tdimx;
      res += dy*dz * (*tpt);        /* tbuf(ix,iy+1,iz+1) */
      *rbuf = res;
      continue;
    }
    /* here we are sure that the border is either
       along the Y or the Z axis */
    dx = x - ix;
    if ( (y < 0.0) || (iy == t1dimy) ) {
      if ( (z < 0.0) || (iz == t1dimz) ) {
	res = (1-dx) * (*tpt); /* tbuf(ix,iy,iz) */
	tpt ++;
	res += dx * (*tpt);    /* tbuf(ix+1,iy,iz) */
	*rbuf = res;
	continue;
      }
      dz = z - iz;
      res = (1-dx)*(1-dz) * (*tpt); /* tbuf(ix,iy,iz) */
      tpt ++;
      res += dx*(1-dz) * (*tpt);    /* tbuf(ix+1,iy,iz) */
      tpt += tdimxy-1;
      res += (1-dx)*dz * (*tpt);    /* tbuf(ix,iy,iz+1) */
      tpt ++;
      res += dx*dz * (*tpt);        /* tbuf(ix+1,iy,iz+1) */
      *rbuf = res;
      continue;
    }
    /* here we are sure that the border is along the Z axis */
    dy = y - iy;
    res = (1-dx)*(1-dy) * (*tpt); /* tbuf(ix,iy,iz) */
    tpt ++;
    res += dx*(1-dy) * (*tpt);    /* tbuf(ix+1,iy,iz) */
    tpt += t1dimx;
    res += (1-dx)*dy * (*tpt);    /* tbuf(ix,iy+1,iz) */
    tpt ++;
    res += dx*dy * (*tpt);        /* tbuf(ix+1,iy+1,iz) */
    *rbuf = res;
  }
}

/* Resampling procedure.

   Work for 3D images, not for vectorial ones.

   Cette procedure utilise un champ de deformations 
   backward, c'est-a-dire allant de l'image a reechantillonner
   a l'image reference. Une fois estime le point apres application
   du champ de deformation, on applique a celui-ci une matrice 
   de transformation.

   Entrees:
   - le buffer de l'image reference
   - une coupe (du meme type) de l'image resultat
   - les 3 coupes de deformations (le vecteur) associees
   - la matrice
   - le numero de la coupe

   Je prefere faire comme ca pour pouvoir facilement gerer 
   une lecture plan par plan du champ de deformation si necessaire.

   Pas de conversion faite a cause de l'eventualite d'un biais et 
   d'un gain.
*/

void ReechNearestDefBack_TYPE ( void *theBuf, /* buffer to be resampled */
			       int *theDim, /* dimensions of buffers */
			       void* resBuf,  /* result buffer */
			       int *resDim,  /* dimensions of this buffer */
			       r32** theDef, /* deformations */
			       double* mat,  /* transformation matrix */
			       int slice     /* slice index */
			       )
{
  register int i, j, k=slice, ix, iy, iz;
  register double xd, yd, zd;
  register double x, y, z;
  int rdimx=resDim[0], rdimy=resDim[1];
  int tdimx=theDim[0], tdimy=theDim[1], tdimz=theDim[2];
  int tdimxy=tdimx*tdimy;
  register double ddimx = (double)tdimx-0.5, ddimy = (double)tdimy-0.5;
  register double ddimz = (double)tdimz-0.5;
  register TYPE *tbuf = (TYPE*)theBuf;
  register TYPE* rbuf = resBuf;
  register r32* defx = theDef[0];
  register r32* defy = theDef[1];
  register r32* defz = theDef[2];

  for ( j = 0; j < rdimy; j ++ )
  for ( i = 0; i < rdimx; i ++, rbuf ++, defx ++, defy ++, defz ++ ) {
    /* computation of the corresponding point after deformation */
    xd = (float)i + *defx;
    yd = (float)j + *defy;
    zd = (float)k + *defz;
    /* computation of the corresponding point after matrix application */
    x = mat[0] * xd +  mat[1] * yd + mat[2] * zd + mat[3];
    if (( x < -0.5 ) || ( x > ddimx)) { *rbuf = 0; continue; }
    y = mat[4] * xd +  mat[5] * yd + mat[6] * zd + mat[7];
    if (( y < -0.5 ) || ( y > ddimy)) { *rbuf = 0; continue; }
    z = mat[8] * xd +  mat[9] * yd + mat[10] * zd + mat[11];
    if (( z < -0.5 ) || ( z > ddimz)) { *rbuf = 0; continue; }

    ix = (int)(x+0.5);
    iy = (int)(y+0.5);
    iz = (int)(z+0.5);

    *rbuf = tbuf[ ix + iy * tdimx + iz * tdimxy ];
  }
}
